# Simplify error handling in complex chains of functions

## Problem

You have a suite of functions that may be deeply nested and you want a clean way to return an error from deep in the call stack.

## Solution

Use panic to propagate an error up the call stack and use a panic handler to turn the panic into a standard error. Be careful not to mask genuine panics raised by the runtime.

```Go
import (
	"runtime"
)

func process() (err error) {
	// Set up the panic handler
	defer func() {
		if e := recover(); e != nil {
			// Check if the panic is from the runtime and propagate it if so.
			if _, ok := e.(runtime.Error); ok {
				panic(e)
			}
			// Retrieve the error
			err = e.(error)
		}
	}()

	// Do the main work of the function
	doSomethingComplex()

	return
}

func doSomethingComplex() {

	// do various things...

	somethingElse()

	// do more things...

}

func somethingElse() {
	// do something that causes an error
    // send the error via panic
	panic(err)
}
```

## Discussion

In deeply nested chains of functions it can be inconvenient to return errors and check the return value of every function call, especially when error conditions are few and rare. In these cases Go's error handling can make the functions less clear and harder to understand.

This recipe shows a possible solution. Write the functions without consideration for errors and panic when an error condition is found. In the top level function, handle the panic and turn it into a standard error to be returned.

The key to the recipe working is in the named return value `err` in the `process` function. Go allows return values to be assigned names which can be useful for documentation purposes. But it also allows another behaviour: the ability to refer to and override the return value using a deferred function. We use this behaviour in this recipe to set the `err` return value to the value recovered from our panic.

The meat of the recipe is in the panic handler. A panic handler is simply a deferred function that calls `recover` to detect and stop the propagation of panics up the call stack. In this recipe's panic handler, the panic is first checked to see if it contains a runtime error.

Runtime errors are a class of errors generated by the Go runtime rather than your program's code or a package your program uses. Runtime errors aren't treated differently by Go but they very often indicate a logic error in the program and as such can be difficult to continue normal execution. Examples of runtime errors include: "index out of range", "integer overflow" and "invalid memory address or nil pointer dereference".

Runtime errors can be detected by testing whether the error `e` implements the `runtime.Error` interface:

```Go
if _, ok := e.(runtime.Error); ok {
```

In the recipe, when we detect that the panic is a runtime error we call panic again which restarts the stack unwinding process and propagates the panic upwards to the start of the program and potentially other panic handlers.

Otherwise we convert the panic into a standard error and assign it to the `err` variable. This overrides any previous value that `err` might have had and allows the caller to test the return value from the `process` function with a standard error test:

```Go
if err := process(); err !=nil {
	println("got error: ", err.Error())
}
```

----
[no rights reserved](http://creativecommons.org/publicdomain/zero/1.0/)

