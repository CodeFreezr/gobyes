package toy

import (
	"math/rand"

	"github.com/sirupsen/logrus"
)

// given a function flip() which simulates a coin-flip and
// returns 1 50% of the time and 0 50% of the time, write a function
// random(n) that generates a random number between 0 & n-1 with
// a normal distribution pattern

func nextPowerOf2(n uint) uint {
	if n > 0 && (n&(n-1)) == 0 {
		return n
	}

	var count uint
	for k := n; k != 0; k >>= 1 {
		logrus.WithFields(logrus.Fields{"k": k, "count": count}).Debug("iterating to next power of 2")
		count += 1
	}
	logrus.WithField("nextPower2", 1<<count).Debug("next power number calculated")
	return 1 << count
}

func flip() bool {
	return rand.Int()%2 == 0
}

// Let m = 2^k >= n where k is is as small as possible.
// do
//   Let r = random number in 0 .. m-1 generated by k coin flips
// while r >= n
// return r
func RandRange(n uint) uint {
	var r = ^uint(0)

	// figure out min # of bits to describe numbers
	var k uint
	m := nextPowerOf2(n)
	for p := m; p != 0; p >>= 1 {
		k += 1
	}
	logrus.WithField("k", k).Info("number of bits to set")

	// calculate
	for r >= n {
		var generated, i uint
		for i = 0; i < k-1; i++ {
			if flip() {
				generated |= 1 << i
				logrus.WithField("generated", generated).Info("flip true")

			} else {
				logrus.WithField("generated", generated).Info("flip false")
			}
		}
		r = generated
		logrus.WithField("r", r).Info("number generated")
	}

	return r
}
