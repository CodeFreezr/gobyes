# Align text in columns

## Problem

You have a series of records that you'd like to display in neat columns but each column is of a different width.

## Solution

Separate each column with a tab and use the `text/tabwriter` package to format the row.

```Go
package main

import (
    "fmt"
    "os"
    "text/tabwriter"
)

type Meteorite struct {
    Name  string
    Class string
    Mass  int
    Year  int
    Lat   float64
    Long  float64
}

var meteorites = []Meteorite{
    Meteorite{Name: "Hoba", Class: "Iron, IVB", Mass: 60000, Year: 1920, Lat: -19.58333, Long: 17.91667},
    Meteorite{Name: "Cape York", Class: "Iron, IIIAB", Mass: 58200, Year: 1818, Lat: 76.13333, Long: -64.93333},
    Meteorite{Name: "Campo del Cielo", Class: "Iron, IAB-MG", Mass: 50000, Year: 1575, Lat: -27.46667, Long: -60.58333},
    Meteorite{Name: "Canyon Diablo", Class: "Iron, IAB-MG", Mass: 30000, Year: 1891, Lat: 35.05, Long: -111.03333},
    Meteorite{Name: "Armanty", Class: "Iron, IIIE", Mass: 28000, Year: 1898, Lat: 47, Long: 88},
    Meteorite{Name: "Gibeon", Class: "Iron, IVA", Mass: 26000, Year: 1836, Lat: -25.5, Long: 18},
    Meteorite{Name: "Chupaderos", Class: "Iron, IIIAB", Mass: 24300, Year: 1852, Lat: 27, Long: -105.1},
    Meteorite{Name: "Mundrabilla", Class: "Iron, IAB-ung", Mass: 24000, Year: 1911, Lat: -30.78333, Long: 127.55},
    Meteorite{Name: "Sikhote-Alin", Class: "Iron, IIAB", Mass: 23000, Year: 1947, Lat: 46.16, Long: 134.65333},
    Meteorite{Name: "Bacubirito", Class: "Iron, ungrouped", Mass: 22000, Year: 1863, Lat: 26.2, Long: -107.83333},
    Meteorite{Name: "Mbosi", Class: "Iron, ungrouped", Mass: 16000, Year: 1930, Lat: -9.11667, Long: 33.06667},
}

func main() {
    tw := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', 0)
    defer tw.Flush()

    fmt.Fprintln(tw, "year\tname\tclass\tmass (kg)\tlatitude\tlongitude\t")

    for _, m := range meteorites {
        fmt.Fprintf(tw, "%d\t%s\t%s\t%d\t% .3f\t% .3f\t\n", m.Year, m.Name, m.Class, m.Mass, m.Lat, m.Long)
    }
}
```

The program outputs:

```
year   name              class             mass (kg)   latitude   longitude
1920   Hoba              Iron, IVB         60000       -19.583     17.917
1818   Cape York         Iron, IIIAB       58200        76.133    -64.933
1575   Campo del Cielo   Iron, IAB-MG      50000       -27.467    -60.583
1891   Canyon Diablo     Iron, IAB-MG      30000        35.050    -111.033
1898   Armanty           Iron, IIIE        28000        47.000     88.000
1836   Gibeon            Iron, IVA         26000       -25.500     18.000
1852   Chupaderos        Iron, IIIAB       24300        27.000    -105.100
1911   Mundrabilla       Iron, IAB-ung     24000       -30.783     127.550
1947   Sikhote-Alin      Iron, IIAB        23000        46.160     134.653
1863   Bacubirito        Iron, ungrouped   22000        26.200    -107.833
1930   Mbosi             Iron, ungrouped   16000       -9.117      33.067
```


## Discussion

In this recipe we have a list of the ten largest meteorite impacts that we want to layout in columns for clarity.  There are several algorithms for layout columns of text and all generally involve the following steps:

1. examine the input to determine the number of columns
2. scan a selection of the rows to determine a maximum width for each column
3. print each row, padding each value so that it takes up the width of the column

The `text/tabwriter` package in Go's standard library implements the Elastic Tabstops algorithm devised by Nick Gravgaard (see http://nickgravgaard.com/elastic-tabstops/index.html). The gofmt tool uses this package to align source code so that comments and variables line up neatly.

Our records are represented by the `Meteorite` type and we start with a slice of 10 records in the `meteorites` variable. In a real program the records may come from a the rows in a database, a stream of readings from sensor or data generated by the program itself. The technique used in this recipe would work with all these different sources of data.

The key to using `text/tabwriter` is to separate each value with a tab character. The tabwriter uses these to determine the column boundaries. The `NewWriter` function takes several arguments which control how the tabs in the rows are interpreted.

* The first argument is an `io.Writer` that the tabwriter should write its output to. This could be a file, a network socket or an in-memory buffer. In this recipe we are using `os.Stdout` which will cause the output to be printed directly to `stdout`.
* The second argument is `minwidth` which specifies the minimum number of characters each column should take up. In the recipe we use 0 which means each column will use the size of its largest value.
* The third argument is `tabwidth` which is only used when the `padchar` argument is a tab, which is the default. `tabwidth` specifies the number of equivalent spaces each tab takes up. This helps the tabwriter determine the correct number of tabs to insert. In our recipe we leave this as zero since we are using space as our `padchar`.
* The fourth argument, `padding`, sets the number of spaces to insert between columns. If this is set to zero then each column will run into the next without a gap. In the recipe we set this to 3 to give some clear space between our columns.
* The fifth argument is `padchar` which is the character that will be used to replace the tabs between each column. By default this is set to be a tab character and the space this character takes up is controlled by the `tabwidth` parameter. In the recipe we use a space instead which guarantees alignment when using a fixed-width font as used by most terminals. If you were expecting to output using a variable-width, proportional font then a tab would be more appropriate. A difficulty arises when using tabs though because you need to use a `tabwidth` that matches the size of tabs used on the output device. This is often 8 but since it's user configurable then there will be times where the columns will not line up due to mismatches in tab settings.
* The sixth and final argument is `flags` which allows some extra control over the formatting. See the `text/tabwriter` documentation for a full explanation of their meanings.

Once the tabwriter has been created we immediately defer a call to its `Flush` method. Because the tabwriter needs to look ahead to determine appropriate column widths it must maintain an internal buffer of written data. If the `Flush` method is not called then it's possible that some output will not be sent to the underlying writer. By deferring the call we guarantee it is called as soon as the `main` function exits.

We then write a list of headers each terminated by a tab so they'll be interpreted as forming columns by the tabwriter. Note that each value is followed by a tab which is different from being tab separated since there is a tab after the last value. The tabwriter uses the tab character to determine the end of a 'cell' of data so it's important to ensure there is a tab after each value. Note how we are using the `fmt.Fprintln` function. This function writes a newline terminated string to the `io.Writer` specified in its first argument. The tabwriter conveniently implements the `io.Writer` interface just like `os.Stdout` does. This is an example of a common pattern in the Go standard library: a type that wraps an `io.Writer` and implements the interface itself. This pattern allows types such as `tabwriter` to act as filters. Anything that could write to `os.Stdout` could just as easily write to `os.Stdout` wrapped by a `tabwriter` and anything written would be transparently formatted into columns.

Finally we loop over all our meteorite records and write each one to the tabwriter using the `fmt.Fprintf` function which allows us to format each field nicely. Let's break down the format string `"%d\t%s\t%s\t%d\t% .3f\t% .3f\t\n"` into its main components:

* `%d\t` means write an integer in base 10 followed by a tab
* `%s\t` means write string followed by a tab
* `% .3f\t` means write a floating point number using the default width with a precision of 3, again followed by a tab. The space after the % sign means use a space for the sign of positive numbers and a - for negative ones which helps line up the numbers. Using `%.3f\t` would lead to a ragged column since positive numbers would be aligned with the `-` symbol rather than the first digit. We could also have written `%+.3f\t` which would force the `+` sign to be used.

Note we have to use `\n` at the end of the format string to ensure there is a newline at the end of the written row.

As we loop through all the rows the tabwriter calculates the appropriate padding for each field and replaces the embedded tab characters with the correct number of characters as specified by the `padchar` argument, a space in our case. You can more easily see the effect of the padding by using a visible character as the padchar instead of a space or tab. Using a period gives the following output:

```
year...name..............class.............mass (kg)...latitude...longitude...
1920...Hoba..............Iron, IVB.........60000.......-19.583.... 17.917.....
1818...Cape York.........Iron, IIIAB.......58200....... 76.133....-64.933.....
1575...Campo del Cielo...Iron, IAB-MG......50000.......-27.467....-60.583.....
1891...Canyon Diablo.....Iron, IAB-MG......30000....... 35.050....-111.033....
1898...Armanty...........Iron, IIIE........28000....... 47.000.... 88.000.....
1836...Gibeon............Iron, IVA.........26000.......-25.500.... 18.000.....
1852...Chupaderos........Iron, IIIAB.......24300....... 27.000....-105.100....
1911...Mundrabilla.......Iron, IAB-ung.....24000.......-30.783.... 127.550....
1947...Sikhote-Alin......Iron, IIAB........23000....... 46.160.... 134.653....
1863...Bacubirito........Iron, ungrouped...22000....... 26.200....-107.833....
1930...Mbosi.............Iron, ungrouped...16000.......-9.117..... 33.067.....
```

Now you can easily see the three characters spacing between the columns and the additional padding at the end of each row caused by the terminating tab.

----
[no rights reserved](http://creativecommons.org/publicdomain/zero/1.0/)







